/*
* Bitset.h is a modified version of the Boost dynamic bitset class,
 * and adheres to the the Boost Software License, Version 1.0.

 * Modifications were made to suit specific needs and design preferences.
 * Any changes beyond this point do not necessarily reflect the views of Boost.
 *
 * License information for Boost Software License, Version 1.0 can be found here:
 * https://www.boost.org/LICENSE_1_0.txt
 */

#ifndef BITSET_H
#define BITSET_H

#include <vector>
#include <numeric>
#include <cstdint>
#include <assert.h>
#include <climits>
#include <ostream>


template <bool dummy_name = true>
struct count_table { static const unsigned char table[]; };

template <>
struct count_table<false> { /* no table */ };

const unsigned int table_width = 8;
template <bool b>
const unsigned char count_table<b>::table[] =
        {
                // Automatically generated by GPTableGen.exe v.1.0
                //
                0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
                1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
                1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
                2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
                1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
                2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
                2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
                3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
        };

class Bitset {
    typedef std::vector<uint64_t> buffer_type;

public:
    static const size_t bits_per_uint64 = std::numeric_limits<uint64_t>::digits;

    // constructors
    Bitset() : m_num_bits(0) {}

    Bitset(size_t num_bits, uint64_t value = 0)
    : m_num_bits(num_bits)
    {
        init(num_bits, value);
    }
    Bitset(const Bitset& b) : m_bitset(b.m_bitset), m_num_bits(b.m_num_bits) {}


    ~Bitset() = default;


    // utils functions
    uint64_t count_extra_bits() const { return bit_index(m_num_bits); }
    static size_t bit_index(size_t pos) {return pos % bits_per_uint64;}
    static size_t block_index(size_t pos) { return pos / bits_per_uint64; }
    static uint64_t bit_mask(size_t pos) { return uint64_t(1) << bit_index(pos); }
    static size_t calc_num_blocks(size_t num_bits) {return num_bits / bits_per_uint64
                                                           + static_cast<std::size_t>(num_bits % bits_per_uint64 != 0);}
    // If size() is not a multiple of bits_per_block
    // then not all the bits in the last block are used.
    // This function resets the unused bits
    void m_zero_unused_bits()
    {
        assert (m_bitset.size() == calc_num_blocks(m_num_bits));

        const uint64_t extra_bits = count_extra_bits();
        if (extra_bits != 0)
            m_bitset.back() &= (uint64_t(1) << extra_bits) - 1;
    }

    // reset functions
    Bitset& reset(size_t pos) {
        // reset the bit in position pos
        m_bitset[block_index(pos)] &= ~bit_mask(pos);
        return *this;
    }
    Bitset& reset()
    {
        std::fill(m_bitset.begin(), m_bitset.end(), uint64_t(0));
        return *this;
    }

    void init(size_t num_bits, uint64_t value) {
        m_bitset.resize(calc_num_blocks(num_bits), value);
    }

    size_t size() const {
        return m_num_bits;
    }

    // resize
    void resize(std::size_t num_bits, bool value) {
        size_t old_size = m_bitset.size();
        size_t required_block = calc_num_blocks(num_bits);

        const uint64_t v = value? std::numeric_limits<uint64_t>::max() : 0;

        if (old_size != required_block) {
            this->m_bitset.resize(num_bits, v);
        }
        if (value && (num_bits > m_num_bits)) {
            // bistset has been increased
            size_t extra_bits = bit_index(m_num_bits);
            if (extra_bits) {
                assert(old_size >= 1 && old_size <= m_bitset.size());
                m_bitset[old_size - 1] |= (v << extra_bits);
            }
        }
        m_num_bits = num_bits;
        m_zero_unused_bits();
    }

    // clear
    void clear() {
        m_bitset.clear();
        m_num_bits = 0;
    }

    // set() functions
    Bitset& set(size_t pos, bool val = true){
        assert(pos < m_num_bits);
        if (val)
            m_bitset[block_index(pos)] |= bit_mask(pos);

        else
            reset(pos);
        return *this;
    }

    Bitset& set() {
        std::fill(m_bitset.begin(), m_bitset.end(), std::numeric_limits<uint64_t>::max());
        m_zero_unused_bits();
        return *this;
    }

    bool get(size_t pos){
        assert (pos < m_num_bits);
        return (this->m_bitset[block_index(pos)] & bit_mask(pos)) != 0;
    }

    template <typename ValueType>
    std::size_t popcount(ValueType value){
        std::size_t num = 0u;
        while (value) {
            num += count_table<>::table[value & ((1u<<table_width) - 1)];
            value >>= table_width;
        }
        return num;
    }

    template <typename T>
    const unsigned char * object_representation (T* p){
        return static_cast<const unsigned char *>(static_cast<const void *>(p));
    }

    template <typename Iterator>
    size_t do_count(Iterator first, std::size_t length, bool access_by_bytes){
        if(!access_by_bytes) {
            // Access by blocks
            std::size_t num1 = 0u, num2 = 0u;
            while (length >= 2u) {
                num1 += popcount<uint64_t>(*first);
                ++first;
                num2 += popcount<uint64_t>(*first);
                ++first;
                length -= 2u;
            }

            if (length > 0u)
                num1 += popcount<uint64_t>(*first);

            return num1 + num2;
        } else {
            // access by bytes
            if (length > 0u) {
                const unsigned char* p = object_representation(&*first);
                length *= sizeof(*first);

                return do_count(p, length, false);
            }
            return 0u;
        }
    }

    size_t count(){
        enum { no_padding = bits_per_uint64 == CHAR_BIT * sizeof(uint64_t) };
        enum { enough_table_width = table_width >= CHAR_BIT };
        enum { uneffective_popcount = sizeof(uint64_t) < sizeof(unsigned int) };
        enum { mode = (no_padding && enough_table_width && uneffective_popcount)
                      ? true
                      : false };
        return do_count(m_bitset.begin(), m_bitset.size(), mode);
    }

    Bitset& operator&=(const Bitset& rhs){
        assert(size() == rhs.size());
        for (size_t i = 0; i < m_bitset.size(); ++i)
            m_bitset[i] &= rhs.m_bitset[i];
        return *this;
    }

    Bitset& operator|=(const Bitset& rhs){
        assert(size() == rhs.size());
        for (size_t i = 0; i < m_bitset.size(); ++i)
            m_bitset[i] |= rhs.m_bitset[i];
        return *this;
    }

    bool empty() const{
        return size() == 0;
    }

    Bitset& flip(){
        for (size_t i = 0; i < m_bitset.size(); ++i)
            m_bitset[i] = ~m_bitset[i];
        m_zero_unused_bits();
        return *this;
    }

    Bitset operator~() const{
        Bitset b(*this);
        b.flip();
        return b;
    }

    friend bool operator==(const Bitset& a, const Bitset& b);

    bool any() const{
        for (size_t i = 0; i < m_bitset.size(); ++i)
            if (m_bitset[i])
                return true;
        return false;
    }

    bool none() const{
        return not any();
    }

private:
    buffer_type m_bitset;
    std::size_t m_num_bits;
};

Bitset operator&(const Bitset& x, const Bitset& y);
Bitset operator|(const Bitset& x, const Bitset& y);
bool operator!=(Bitset& a, Bitset& b);
bool operator==(const Bitset& a, const Bitset& b);


template <typename Ch, typename Tr>
std::basic_ostream<Ch, Tr>&
operator<<(std::basic_ostream<Ch, Tr>& os,
           Bitset& b)
{

    using namespace std;

    const ios_base::iostate ok = ios_base::goodbit;
    ios_base::iostate err = ok;

    typename basic_ostream<Ch, Tr>::sentry cerberos(os);
    if (cerberos) {

        const Ch zero = '0';
        const Ch one = '1';

        try {

            typedef uint64_t bitset_size_type;
            typedef basic_streambuf<Ch, Tr> buffer_type;

            buffer_type *buf = os.rdbuf();
            // careful: os.width() is signed (and can be < 0)
            const bitset_size_type width = (os.width() <= 0) ? 0 : static_cast<bitset_size_type>(os.width());
            streamsize npad = (width <= b.size()) ? 0 : width - b.size();

            const Ch fill_char = os.fill();
            const ios_base::fmtflags adjustfield = os.flags() & ios_base::adjustfield;

            // if needed fill at left; pad is decreased along the way
            if (adjustfield != ios_base::left) {
                for (; 0 < npad; --npad)
                    if (Tr::eq_int_type(Tr::eof(), buf->sputc(fill_char))) {
                        err |= ios_base::failbit;
                        break;
                    }
            }

            if (err == ok) {
                // output the bitset
                for (bitset_size_type i = b.size(); 0 < i; --i) {
                    typename buffer_type::int_type
                            ret = buf->sputc(b.get(i - 1) ? one : zero);
                    if (Tr::eq_int_type(Tr::eof(), ret)) {
                        err |= ios_base::failbit;
                        break;
                    }
                }
            }

            if (err == ok) {
                // if needed fill at right
                for (; 0 < npad; --npad) {
                    if (Tr::eq_int_type(Tr::eof(), buf->sputc(fill_char))) {
                        err |= ios_base::failbit;
                        break;
                    }
                }
            }


            os.width(0);

        } catch (...) { // see std 27.6.1.1/4
            bool rethrow = false;
            try { os.setstate(ios_base::failbit); } catch (...) { rethrow = true; }

            if (rethrow)
                throw;
        }
    }

    if(err != ok)
        os.setstate(err); // may throw exception
    return os;

}
#endif
